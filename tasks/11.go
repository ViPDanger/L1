//	Реализовать пересечение двух неупорядоченных множеств.

// Комментарий автора
// Т.К Кое кто умеет пользоваться гуглом (но слишком поздно) все данные функции работают
// на МУЛЬТИмножествах, т.е. с учётом, что элементы могут повторяться
// Естественно, данные функции работают и на обычных множествах, но используют ненужные проверки.
// В качестве проверочных данных введены мультимножества.
package tasks

import (
	"fmt"
	"sort"
)

// Вариант с map O(N1+N2). Самое быстрое решение
func Task11_1() {
	// Множества
	arr1 := []int{1, 4, 51, 4, 2, 5, 78, 51, 41, 56, 21, 556}
	arr2 := []int{5, 5, 1, 23, 5, 6, 8, 7, 543, 2, 4, 5, 7, 8, 123, 45, 56, 21}
	Map := make(map[int]int) //Инициализация мапы
	result := make([]int, 0)
	// Считаем кол-во обьектов на ключ map
	for _, a := range arr1 {
		Map[a]++
	}
	//
	for _, a := range arr2 {
		if Map[a] > 0 {
			Map[a]--
			result = append(result, a)
		}
	}
	fmt.Println(result)
}

// Вариант с сортировкой
func Task11_2() {
	// Множества
	arr1 := make([]int, 0)
	arr2 := make([]int, 0)
	arr1 = append(arr1, 1, 4, 51, 4, 2, 5, 78, 51, 41, 56, 21, 556)
	arr2 = append(arr2, 5, 5, 1, 23, 5, 6, 8, 7, 543, 2, 4, 5, 7, 8, 123, 45, 56, 21)
	// Сортируем множества
	sort.Ints(arr1)
	sort.Ints(arr2)

	result := make([]int, 0)
	i1, i2 := 0, 0
	// Пошаговое сравнение
	for i1 < len(arr1) && i2 < len(arr2) {
		if arr1[i1] == arr2[i2] {
			result = append(result, arr1[i1])
			i1++
			i2++
		} else {
			if arr1[i1] < arr2[i2] {
				i1++
			} else {
				i2++
			}
		}
	}
	fmt.Println(result)
}

// Для пересечения нам не нужно сортировать множества.
// Достаточно пройтись по кажому варрианту и получим O(N1*N2).
func Task11_3() {
	// Множества
	arr1 := []int{1, 4, 51, 4, 2, 5, 78, 51, 41, 56, 21, 556}
	arr2 := []int{5, 5, 1, 23, 5, 6, 8, 7, 543, 2, 4, 5, 7, 8, 123, 45, 56, 21}
	result := make([]int, 0)
	// Находим одинаковые значения
	for i1 := 0; i1 < len(arr1); i1++ {
		for i2 := 0; i2 < len(arr2); i2++ {
			if arr1[i1] == arr2[i2] {
				// На одно значение arr1 может приходиться несколько значений arr2 и наоборот
				// Нам необходимо это учитывать
				result = append(result, arr1[i1])
				arr2 = append(arr2[:i2], arr2[i2+1:]...)
				break
			}
		}
	}
	sort.Ints(result)
	fmt.Println(result)
}
