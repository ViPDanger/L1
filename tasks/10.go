// Дана последовательность температурных колебаний: -25.4, -27.0 13.0, 19.0,
// 15.5, 24.5, -21.0, 32.5. Объединить данные значения в группы с шагом в 10
// градусов. Последовательность в подмножноствах не важна.
package tasks

import "fmt"

func Task10_1() {
	// Последовательность температурных колебаний arr
	arr := []float64{-25.4, -27.0, 13.0, 19.0, 15.5, 24.5, -21.0, 32.5}
	// Map с ссылками на слайсы float64. В неё мы будем записывать данные.
	// т.к. мы не хотим связываться с переполнением бакетов и последующей
	// миграцией map, используем именно Ссылки на слайсы float
	Map := make(map[int]*[]float64, len(arr)*2)
	for _, float := range arr {
		key := (int(float) / 10) * 10
		// Добавляем ключ в Map при его отсутствии
		if Map[key] == nil {
			floatarr := make([]float64, 0)
			Map[key] = &floatarr
		}
		// Добавляем значение в массив ключа Map
		*(Map[key]) = append(*(Map[key]), float)
	}
	// Вывод данных. Из-за того что нам приходится таскать данные со ссылок, выглядит чуть менее красиво
	for _, addres := range Map {
		fmt.Println(int((*addres)[0])/10*10, *addres)
	}
}

// Сделаем то же самое, но с мапой слайсов.
func Task10_2() {

	// Последовательность температурных колебаний arr
	arr := []float64{-25.4, -27.0, 13.0, 19.0, 15.5, 24.5, -21.0, 32.5}
	// Мапа слайсов
	Map := make(map[int][]float64, len(arr)*2)
	for _, float := range arr {
		key := (int(float) / 10) * 10
		// Добавляем ключ в Map при его отсутствии
		if Map[key] == nil {
			Map[key] = make([]float64, 0)
		}
		// Добавляем значение в массив ключа Map
		Map[key] = append(Map[key], float)
	}
	// Код выглядит красивее, но при большом len(arr) нам придётся столкнуться с миграцией
	fmt.Println(Map)
}
